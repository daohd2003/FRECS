@page "/customer/messages"
@model ShareItFE.Pages.Customer.MessagesModel
@{
    ViewData["Title"] = "My Messages";
}
<link rel="stylesheet" href="~/css/chat.css" />

<div class="chat-container">
    <div class="conversation-list">
        <div class="conversation-list-header">
            <h2>Messages</h2>
        </div>
        <div id="conversation-list-body" class="conversation-list-body">
            <p class="loading-text">Loading conversations...</p>
        </div>
    </div>

    <div class="chat-view">
        <div id="chat-placeholder" class="chat-placeholder">
            <p>Select a conversation to begin</p>
        </div>

        <div id="chat-window" class="chat-window hidden">
            <div id="chat-header" class="chat-header">
                <h3 id="chat-user-name" class="name"></h3>
            </div>

            <div id="product-context-banner" class="product-context-banner hidden">
                <a id="product-link" href="#" target="_blank" rel="noopener noreferrer">
                    <img id="product-image" src="" alt="Product" />
                    <div>
                        <p class="topic-text">Topic:</p>
                        <p id="product-name" class="product-name"></p>
                    </div>
                </a>
            </div>

            <div id="messages-container" class="messages-container"></div>

            <form id="send-message-form" class="message-form">
                <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off" disabled>
                <button type="submit" id="send-btn" disabled>Send</button>
            </form>
        </div>
    </div>
</div>
@section Scripts {
    <script src="~/js/dist/browser/signalr.js"></script>
    <style>
        /* Voice message player styles */
        .voice-message-player {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 20px;
            min-width: 180px;
            max-width: 240px;
        }
        .message-bubble.me .voice-message-player {
            background: rgba(255, 255, 255, 0.2);
        }
        .voice-play-btn {
            width: 32px;
            height: 32px;
            min-width: 32px;
            border-radius: 50%;
            border: none;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
        }
        .message-bubble.them .voice-play-btn {
            background: #667eea;
        }
        .voice-waveform-display {
            flex: 1;
            height: 24px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        .voice-waveform-display .waveform-bar {
            width: 3px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 2px;
            transition: background 0.1s;
        }
        .message-bubble.me .voice-waveform-display .waveform-bar {
            background: rgba(255, 255, 255, 0.4);
        }
        .voice-waveform-display .waveform-bar.active {
            background: #667eea;
        }
        .message-bubble.me .voice-waveform-display .waveform-bar.active {
            background: white;
        }
        .voice-duration-display {
            font-size: 12px;
            font-family: monospace;
            min-width: 32px;
            text-align: right;
        }
    </style>
    <script>
        // Helper function for waveform bars
        function generateWaveformBars(count) {
            let bars = '';
            for (let i = 0; i < count; i++) {
                const height = Math.random() * 60 + 20;
                bars += '<div class="waveform-bar" style="height: ' + height + '%"></div>';
            }
            return bars;
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const conversationListEl = document.getElementById('conversation-list-body');
            const chatPlaceholderEl = document.getElementById('chat-placeholder');
            const chatWindowEl = document.getElementById('chat-window');
            const chatUserNameEl = document.getElementById('chat-user-name');
            const messagesContainerEl = document.getElementById('messages-container');
            const sendMessageForm = document.getElementById('send-message-form');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const productBannerEl = document.getElementById('product-context-banner');
            const productImageEl = document.getElementById('product-image');
            const productNameEl = document.getElementById('product-name');
            const productLinkEl = document.getElementById('product-link');

            const currentUserId = '@Model.CurrentUserId';
            const accessToken = '@Model.AccessToken';
            const apiUrl = '@Model.ApiBaseUrl';
            const signalRUrl = '@Model.SignalRRootUrl';

            let conversations = [];
            let currentPage = 1;
            const pageSize = 15;
            let selectedConversation = null;
            let signalRConnection = null;
            let isLoadingMore = false;

            function createMessageElement(message, isMe) {
                const messageRow = document.createElement('div');
                messageRow.className = isMe ? 'message-row me' : 'message-row them';

                // Create container for bubble and timestamp
                const bubbleContainer = document.createElement('div');
                bubbleContainer.classList.add('message-bubble-container', isMe ? 'me' : 'them');

                const bubbleDiv = document.createElement('div');
                bubbleDiv.className = 'message-bubble';
                if (isMe) {
                    bubbleDiv.classList.add('me');
                } else {
                    bubbleDiv.classList.add('them');
                }
                
                if (message.attachment) {
                    const att = message.attachment;
                    if (att.type === 'image') {
                        const img = document.createElement('img');
                        img.src = att.url;
                        img.alt = att.fileName || 'image';
                        img.style.maxWidth = '260px';
                        img.style.borderRadius = '8px';
                        img.style.cursor = 'zoom-in';
                        img.addEventListener('click', () => openLightbox(att.url));
                        bubbleDiv.appendChild(img);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    } else if (att.type === 'video') {
                        const video = document.createElement('video');
                        video.src = att.url;
                        video.controls = true;
                        video.style.maxWidth = '260px';
                        video.style.borderRadius = '8px';
                        bubbleDiv.appendChild(video);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    } else if (att.type === 'audio') {
                        // Voice message with custom player
                        const audioId = 'audio_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        const voiceContainer = document.createElement('div');
                        voiceContainer.className = 'voice-message-player';
                        voiceContainer.innerHTML = `
                            <button type="button" class="voice-play-btn" data-audio-id="${audioId}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M8 5v14l11-7z"/>
                                </svg>
                            </button>
                            <div class="voice-waveform-display">
                                ${generateWaveformBars(15)}
                            </div>
                            <span class="voice-duration-display">0:00</span>
                            <audio id="${audioId}" src="${att.url}" style="display:none"></audio>
                        `;
                        bubbleDiv.appendChild(voiceContainer);
                        
                        // Setup audio player after adding to DOM
                        setTimeout(() => {
                            const audio = document.getElementById(audioId);
                            const playBtn = voiceContainer.querySelector('.voice-play-btn');
                            const durationEl = voiceContainer.querySelector('.voice-duration-display');
                            const waveformBars = voiceContainer.querySelectorAll('.waveform-bar');
                            
                            if (audio) {
                                audio.addEventListener('loadedmetadata', () => {
                                    if (audio.duration && !isNaN(audio.duration)) {
                                        const mins = Math.floor(audio.duration / 60);
                                        const secs = Math.floor(audio.duration % 60);
                                        durationEl.textContent = mins + ':' + secs.toString().padStart(2, '0');
                                    }
                                });
                                
                                playBtn.addEventListener('click', () => {
                                    if (audio.paused) {
                                        // Stop other audios
                                        document.querySelectorAll('.voice-message-player audio').forEach(a => {
                                            if (a.id !== audioId && !a.paused) {
                                                a.pause();
                                                a.currentTime = 0;
                                                const otherContainer = a.closest('.voice-message-player');
                                                if (otherContainer) {
                                                    otherContainer.querySelector('.voice-play-btn').innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
                                                    otherContainer.querySelectorAll('.waveform-bar').forEach(b => b.classList.remove('active'));
                                                }
                                            }
                                        });
                                        audio.play();
                                        playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>';
                                    } else {
                                        audio.pause();
                                        playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
                                    }
                                });
                                
                                audio.addEventListener('timeupdate', () => {
                                    const remaining = Math.max(0, Math.ceil(audio.duration - audio.currentTime));
                                    const mins = Math.floor(remaining / 60);
                                    const secs = remaining % 60;
                                    durationEl.textContent = mins + ':' + secs.toString().padStart(2, '0');
                                    
                                    // Update waveform
                                    const progress = audio.currentTime / audio.duration;
                                    const activeCount = Math.floor(progress * waveformBars.length);
                                    waveformBars.forEach((bar, i) => {
                                        if (i < activeCount) bar.classList.add('active');
                                        else bar.classList.remove('active');
                                    });
                                });
                                
                                audio.addEventListener('ended', () => {
                                    playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
                                    waveformBars.forEach(b => b.classList.remove('active'));
                                    audio.currentTime = 0;
                                    const mins = Math.floor(audio.duration / 60);
                                    const secs = Math.floor(audio.duration % 60);
                                    durationEl.textContent = mins + ':' + secs.toString().padStart(2, '0');
                                });
                            }
                        }, 100);
                        
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    } else {
                        const link = document.createElement('a');
                        link.href = att.url;
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.textContent = att.fileName || 'Download file';
                        bubbleDiv.appendChild(link);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    }
                } else {
                    bubbleDiv.textContent = message.content;
                }

                // Create timestamp element
                const timestampDiv = document.createElement('div');
                timestampDiv.classList.add('message-timestamp');
                
                // Format timestamp
                let formattedTime = '';
                if (message.sentAt || message.timestamp) {
                    const msgDate = new Date(message.sentAt || message.timestamp);
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const msgDateOnly = new Date(msgDate.getFullYear(), msgDate.getMonth(), msgDate.getDate());
                    
                    if (msgDateOnly.getTime() === today.getTime()) {
                        // Today - show only time
                        formattedTime = msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    } else if (msgDateOnly.getTime() === today.getTime() - 24 * 60 * 60 * 1000) {
                        // Yesterday
                        formattedTime = 'Hôm qua ' + msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    } else {
                        // Older - show date and time
                        formattedTime = msgDate.toLocaleDateString('vi-VN', { 
                            day: '2-digit', 
                            month: '2-digit',
                            year: 'numeric'
                        }) + ' ' + msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    }
                } else {
                    // Fallback for messages without timestamp
                    formattedTime = new Date().toLocaleTimeString('vi-VN', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                }
                
                timestampDiv.textContent = formattedTime;
                
                // Add click handler to toggle timestamp
                bubbleDiv.addEventListener('click', function() {
                    timestampDiv.classList.toggle('show');
                });
                
                // Assemble the message
                bubbleContainer.appendChild(bubbleDiv);
                bubbleContainer.appendChild(timestampDiv);
                messageRow.appendChild(bubbleContainer);
                
                return messageRow;
            }

            function renderConversationList() {
                conversationListEl.innerHTML = '';
                conversations
                    .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))
                    .forEach(convo => {
                        const convoEl = document.createElement('div');
                        convoEl.className = 'conversation-item';
                        if (selectedConversation && convo.id === selectedConversation.id) {
                            convoEl.classList.add('selected');
                        }
                        convoEl.dataset.conversationId = convo.id;

                        const unreadBadge = (convo.unreadMessageCount || 0) > 0 ? `<span class=\"badge-unread\">${convo.unreadMessageCount}</span>` : '';

                        const productTopicHtml = convo.productContext
                            ? `<p class="product-topic">Topic: ${convo.productContext.name}</p>`
                            : '';

                        convoEl.innerHTML = `
                        <div class="avatar">
                            <img src="${convo.otherParticipant.profilePictureUrl || 'https://via.placeholder.com/100'}" />
                        </div>
                        <div class="details">
                            <div class="header">
                                <p class="name">${convo.otherParticipant.fullName}
                                    ${convo.otherParticipant.role ? `<span style=\"margin-left:6px; font-size:12px; color:#6b7280;\">(${convo.otherParticipant.role})</span>` : ''}
                                </p>
                                ${unreadBadge}
                            </div>
                            ${productTopicHtml}
                            <p class="last-message">${convo.lastMessageContent || 'No messages yet'}</p>
                        </div>
                    `;

                        convoEl.addEventListener('click', () => selectConversation(convo.id));
                        conversationListEl.appendChild(convoEl);
                    });
            }

            async function loadConversations() {
                try {
                    // ✅ Cache-busting: Force fresh data mỗi lần load
                    const response = await fetch(`${apiUrl}/conversations?_=${Date.now()}`, {
                        headers: { 
                            'Authorization': 'Bearer ' + accessToken,
                            'Cache-Control': 'no-cache' // ✅ Disable browser cache
                        }
                    });
                    if (!response.ok) throw new Error("Failed to load conversations");
                    conversations = await response.json();
                    renderConversationList();
                } catch (error) {
                    conversationListEl.innerHTML = `<p class="loading-text" style="color: red;">${error.message}</p>`;
                }
            }

            async function loadMessages(conversationId, page) {
                try {
                    const response = await fetch(`${apiUrl}/conversations/${conversationId}/messages?pageNumber=${page}&pageSize=${pageSize}`, {
                        headers: { 'Authorization': 'Bearer ' + accessToken }
                    });
                    if (!response.ok) throw new Error("Failed to load messages");

                    const messages = await response.json();

                    // Thêm vào đầu (cũ nhất trên đầu, mới nhất ở dưới)
                    messages.reverse().forEach(msg => {
                        const isMe = msg.senderId.toLowerCase() === currentUserId.toLowerCase();
                        const el = createMessageElement(msg, isMe);
                        messagesContainerEl.insertBefore(el, messagesContainerEl.firstChild);
                    });

                    return messages.length;
                } catch (err) {
                    console.error(err);
                    return 0;
                }
            }

            async function selectConversation(conversationId) {
                selectedConversation = conversations.find(c => c.id === conversationId);
                if (!selectedConversation) return;

                renderConversationList();

                chatPlaceholderEl.classList.add('hidden');
                chatWindowEl.classList.remove('hidden');
                chatUserNameEl.textContent = selectedConversation.otherParticipant.fullName + (selectedConversation.otherParticipant.role ? ` (${selectedConversation.otherParticipant.role})` : '');

                if (selectedConversation.productContext) {
                    productImageEl.src = selectedConversation.productContext.imageUrl || 'https://via.placeholder.com/100';
                    productNameEl.textContent = selectedConversation.productContext.name;
                    productLinkEl.href = `${window.apiSettings.frontendUrl}/products/detail/${selectedConversation.productContext.id}`;
                    productBannerEl.classList.remove('hidden');
                } else {
                    productBannerEl.classList.add('hidden');
                }

                messagesContainerEl.innerHTML = '<p style="text-align: center; color: #6b7280;">Loading messages...</p>';
                messagesContainerEl.innerHTML = '';
                currentPage = 1;
                await loadMessages(conversationId, currentPage);
                messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight; // Scroll xuống dưới

                messageInput.disabled = false;
                sendBtn.disabled = false;

                // Mark as read on server and reset badge locally
                try {
                    await fetch(`${apiUrl}/conversations/${conversationId}/mark-read`, {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + accessToken }
                    });
                    const idx = conversations.findIndex(c => c.id === conversationId);
                    if (idx >= 0) { conversations[idx].unreadMessageCount = 0; renderConversationList(); }
                } catch {}
            }

            sendMessageForm.addEventListener('submit', (e) => {
                e.preventDefault();
                if (!selectedConversation) return;

                const messageText = messageInput.value.trim();
                if (messageText && signalRConnection) {
                    const recipientId = selectedConversation.otherParticipant.userId;

                    // Create temporary message with timestamp for immediate display
                    const tempMessage = {
                        content: messageText,
                        senderId: currentUserId,
                        sentAt: new Date().toISOString()
                    };
                    
                    // Display message immediately
                    const el = createMessageElement(tempMessage, true);
                    messagesContainerEl.appendChild(el);
                    messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;

                    signalRConnection.invoke("SendMessageAsync", selectedConversation.id, recipientId, messageText, null) // Thêm `null` ở cuối
                        .then(() => {
                            messageInput.value = '';
                        })
                        .catch(err => {
                            console.error("Failed to send message:", err);
                            alert("Could not send message. Please try again.");
                        });
                }
            });

            // --- Upload attachment ---
            const uploadInput = document.createElement('input');
            uploadInput.type = 'file';
            uploadInput.style.display = 'none';
            uploadInput.accept = 'image/*,video/*,*/*';
            uploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                uploadInput.value = '';
                if (!file || !selectedConversation || !signalRConnection) return;
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    const res = await fetch(`${apiUrl}/chat/attachments`, {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + accessToken },
                        body: formData
                    });
                    if (!res.ok) throw new Error('Upload failed');
                    const { data } = await res.json();
                    const recipientId = selectedConversation.otherParticipant.userId;
                    await signalRConnection.invoke('SendMessageWithAttachmentAsync',
                        selectedConversation.id,
                        recipientId,
                        messageInput.value.trim() || null,
                        null,
                        data.url,
                        data.type,
                        data.publicId,
                        data.thumbnailUrl,
                        data.mimeType,
                        data.fileName,
                        data.fileSize
                    );
                    messageInput.value = '';
                } catch (err) {
                    console.error(err);
                    alert('Failed to send attachment');
                }
            });

            const attachBtn = document.createElement('button');
            attachBtn.type = 'button';
            attachBtn.title = 'Attach';
            attachBtn.setAttribute('aria-label', 'Attach');
            attachBtn.style.background = 'transparent';
            attachBtn.style.border = 'none';
            attachBtn.style.padding = '0 6px';
            attachBtn.style.cursor = 'pointer';
            attachBtn.style.color = '#000';
            attachBtn.className = 'attach-btn';
            attachBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 1 1 5.66 5.66l-9.2 9.19a2 2 0 1 1-2.83-2.83l8.49-8.48"/></svg>';
            attachBtn.addEventListener('click', () => uploadInput.click());
            // đặt icon trong thanh nhập: trước nút Send
            sendMessageForm.insertBefore(attachBtn, sendBtn);
            sendMessageForm.appendChild(uploadInput);

            // --- Lightbox for image preview ---
            function openLightbox(url) {
                let overlay = document.getElementById('image-lightbox');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'image-lightbox';
                    overlay.style.position = 'fixed';
                    overlay.style.inset = '0';
                    overlay.style.background = 'rgba(0,0,0,0.85)';
                    overlay.style.display = 'flex';
                    overlay.style.alignItems = 'center';
                    overlay.style.justifyContent = 'center';
                    overlay.style.zIndex = '10000';
                    const img = document.createElement('img');
                    img.style.maxWidth = '90%';
                    img.style.maxHeight = '90%';
                    img.style.borderRadius = '8px';
                    overlay.appendChild(img);
                    overlay.addEventListener('click', () => overlay.remove());
                    document.body.appendChild(overlay);
                }
                const imgEl = overlay.querySelector('img');
                imgEl.src = url;
            }

            messagesContainerEl.addEventListener('scroll', async () => {
                if (messagesContainerEl.scrollTop <= 50 && !isLoadingMore) {
                    isLoadingMore = true;
                    const prevHeight = messagesContainerEl.scrollHeight;
                    currentPage++;
                    const loaded = await loadMessages(selectedConversation.id, currentPage);
                    if (loaded > 0) {
                        const newHeight = messagesContainerEl.scrollHeight;
                        messagesContainerEl.scrollTop = newHeight - prevHeight;
                    }
                    isLoadingMore = false;
                }
            });

            async function init() {
                if (!accessToken) {
                    conversationListEl.innerHTML = '<p class="loading-text">Please login to view messages.</p>';
                    return;
                }

                await loadConversations();

                if (!signalRConnection) {
                    signalRConnection = new signalR.HubConnectionBuilder()
                        .withUrl(`${signalRUrl}/chathub?access_token=${accessToken}`)
                        .withAutomaticReconnect()
                        .build();

                    signalRConnection.on("ReceiveMessage", (message) => {
                        const convoToUpdate = conversations.find(c => c.id === message.conversationId);
                        if (convoToUpdate) {
                            // Cập nhật lastMessageContent - hiển thị thông tin attachment nếu có
                            if (message.attachment) {
                                const attachmentType = message.attachment.type;
                                if (attachmentType === 'image') {
                                    convoToUpdate.lastMessageContent = message.content || '📷 Sent an image';
                                } else if (attachmentType === 'video') {
                                    convoToUpdate.lastMessageContent = message.content || '🎥 Sent a video';
                                } else {
                                    convoToUpdate.lastMessageContent = message.content || `📎 ${message.attachment.fileName || 'Sent a file'}`;
                                }
                            } else {
                                convoToUpdate.lastMessageContent = message.content;
                            }
                            convoToUpdate.updatedAt = message.sentAt;
                            convoToUpdate.productContext = message.productContext;
                            if (!selectedConversation || message.conversationId !== selectedConversation.id) {
                                convoToUpdate.unreadMessageCount = (convoToUpdate.unreadMessageCount || 0) + 1;
                            }
                            renderConversationList();
                        } else {
                            // ✅ NEW: Conversation mới (chưa có trong danh sách) → Reload
                            console.log("[CHAT] New conversation detected - reloading conversation list");
                            loadConversations(); // Reload để hiển thị conversation mới
                        }

                        if (selectedConversation && message.conversationId === selectedConversation.id) {
                            const isMe = message.senderId.toLowerCase() === currentUserId.toLowerCase();
                            // Hiển thị tin nhắn: với attachment thì luôn hiển thị, với text thì chỉ hiển thị từ người khác
                            const hasAttachment = message.attachment && message.attachment.url;
                            if (!isMe || hasAttachment) {
                                // Nếu là tin nhắn của mình có attachment, cần hiển thị vì không có temp message cho attachment
                                if (isMe && hasAttachment) {
                                    const el = createMessageElement(message, isMe);
                                    messagesContainerEl.appendChild(el);
                                    messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;
                                } else if (!isMe) {
                                    const el = createMessageElement(message, isMe);
                                    messagesContainerEl.appendChild(el); // Thêm vào CUỐI
                                    messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight; // Scroll xuống dưới
                                }
                            }
                            // QUAN TRỌNG: Cập nhật banner sản phẩm ngay lập tức (regardless of who sent it)
                            if (message.productContext) {
                                productImageEl.src = message.productContext.imageUrl || 'https://www.shutterstock.com/image-vector/image-icon-trendy-flat-style-600nw-643080895.jpg';
                                productNameEl.textContent = message.productContext.name;
                                productLinkEl.href = `${window.apiSettings.frontendUrl}/products/detail/${message.productContext.id}`;
                                productBannerEl.classList.remove('hidden');
                            } else {
                                // Nếu tin nhắn mới không có context, có thể chọn ẩn banner đi hoặc giữ nguyên
                                // productBannerEl.classList.add('hidden');
                            }
                        }
                    });

                    try {
                        await signalRConnection.start();
                        console.log("SignalR Connected.");
                    } catch (err) {
                        console.error("SignalR Connection Error: ", err);
                    }
                }
            }

            init();
        });
    </script>
}