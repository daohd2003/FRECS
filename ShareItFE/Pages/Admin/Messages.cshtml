@page "/admin/messages"
@model ShareItFE.Pages.Admin.MessagesModel
@{
    ViewData["Title"] = "Admin Messages";
    Layout = "_AdminLayout";
}

<link rel="stylesheet" href="~/css/chat.css" />

<div class="chat-container">
    <div class="conversation-list">
        <div class="conversation-list-header">
            <h2>Messages</h2>
        </div>
        <div id="conversation-list-body" class="conversation-list-body">
            <p class="loading-text">Loading conversations...</p>
        </div>
    </div>

    <div class="chat-view">
        <div id="chat-placeholder" class="chat-placeholder">
            <p>Select a conversation to begin</p>
        </div>

        <div id="chat-window" class="chat-window hidden">
            <div id="chat-header" class="chat-header">
                <h3 id="chat-user-name" class="name"></h3>
            </div>

            <div id="product-context-banner" class="product-context-banner hidden">
                <a id="product-link" href="#" target="_blank" rel="noopener noreferrer">
                    <img id="product-image" src="" alt="Product" />
                    <div>
                        <p class="topic-text">Topic:</p>
                        <p id="product-name" class="product-name"></p>
                    </div>
                </a>
            </div>

            <div id="messages-container" class="messages-container"></div>

            <form id="send-message-form" class="message-form">
                <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off" disabled>
                <button type="submit" id="send-btn" disabled>Send</button>
            </form>
        </div>
    </div>
    
</div>

@section Scripts {
    <script src="~/js/dist/browser/signalr.js"></script>
    <script>
        function generateWaveformBars(count) { let bars = ''; for (let i = 0; i < count; i++) { bars += '<div class="waveform-bar" style="height: ' + (Math.random() * 60 + 20) + '%"></div>'; } return bars; }
        function setupVoicePlayer(audioId, container) {
            const audio = document.getElementById(audioId);
            const playBtn = container.querySelector('.voice-play-btn');
            const durationEl = container.querySelector('.voice-duration-display');
            const waveformBars = container.querySelectorAll('.waveform-bar');
            if (!audio) return;
            audio.addEventListener('loadedmetadata', () => { if (audio.duration && !isNaN(audio.duration)) { durationEl.textContent = Math.floor(audio.duration/60) + ':' + Math.floor(audio.duration%60).toString().padStart(2,'0'); } });
            playBtn.addEventListener('click', () => {
                if (audio.paused) { document.querySelectorAll('.voice-message-player audio').forEach(a => { if (a.id !== audioId && !a.paused) { a.pause(); a.currentTime = 0; const c = a.closest('.voice-message-player'); if(c) { c.querySelector('.voice-play-btn').innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>'; c.querySelectorAll('.waveform-bar').forEach(b => b.classList.remove('active')); } } }); audio.play(); playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>'; }
                else { audio.pause(); playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>'; }
            });
            audio.addEventListener('timeupdate', () => { const r = Math.max(0, Math.ceil(audio.duration - audio.currentTime)); durationEl.textContent = Math.floor(r/60) + ':' + (r%60).toString().padStart(2,'0'); const p = audio.currentTime / audio.duration; const ac = Math.floor(p * waveformBars.length); waveformBars.forEach((b,i) => { if(i < ac) b.classList.add('active'); else b.classList.remove('active'); }); });
            audio.addEventListener('ended', () => { playBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>'; waveformBars.forEach(b => b.classList.remove('active')); audio.currentTime = 0; durationEl.textContent = Math.floor(audio.duration/60) + ':' + Math.floor(audio.duration%60).toString().padStart(2,'0'); });
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const conversationListEl = document.getElementById('conversation-list-body');
            const chatPlaceholderEl = document.getElementById('chat-placeholder');
            const chatWindowEl = document.getElementById('chat-window');
            const chatUserNameEl = document.getElementById('chat-user-name');
            const messagesContainerEl = document.getElementById('messages-container');
            const sendMessageForm = document.getElementById('send-message-form');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const productBannerEl = document.getElementById('product-context-banner');
            const productImageEl = document.getElementById('product-image');
            const productNameEl = document.getElementById('product-name');
            const productLinkEl = document.getElementById('product-link');

            const currentUserId = '@Model.CurrentUserId';
            const accessToken = '@Model.AccessToken';
            const apiUrl = '@Model.ApiBaseUrl';
            const signalRUrl = '@Model.SignalRRootUrl';

            let conversations = [];
            let currentPage = 1;
            const pageSize = 15;
            let selectedConversation = null;
            let signalRConnection = null;
            let isLoadingMore = false;

            function createMessageElement(message, isMe) {
                const messageRow = document.createElement('div');
                messageRow.className = isMe ? 'message-row me' : 'message-row them';

                // Create container for bubble and timestamp
                const bubbleContainer = document.createElement('div');
                bubbleContainer.classList.add('message-bubble-container', isMe ? 'me' : 'them');

                const bubbleDiv = document.createElement('div');
                bubbleDiv.className = 'message-bubble';
                if (isMe) {
                    bubbleDiv.classList.add('me');
                } else {
                    bubbleDiv.classList.add('them');
                }
                
                if (message.attachment) {
                    const att = message.attachment;
                    // Check if this is a voice message (webm from voice recording)
                    const isVoiceMessage = att.type === 'audio' || 
                        (att.mimeType && att.mimeType.includes('audio')) ||
                        (att.fileName && att.fileName.includes('voice')) ||
                        (att.url && att.url.includes('.webm') && att.type === 'video');
                    
                    if (att.type === 'image') {
                        const img = document.createElement('img');
                        img.src = att.url;
                        img.alt = att.fileName || 'image';
                        img.style.maxWidth = '260px';
                        img.style.borderRadius = '8px';
                        img.style.cursor = 'zoom-in';
                        img.addEventListener('click', () => openLightbox(att.url));
                        bubbleDiv.appendChild(img);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    } else if (att.type === 'video' && !isVoiceMessage) {
                        const video = document.createElement('video');
                        video.src = att.url;
                        video.controls = true;
                        video.style.maxWidth = '260px';
                        video.style.borderRadius = '8px';
                        bubbleDiv.appendChild(video);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    } else if (isVoiceMessage) {
                        const audioId = 'audio_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        const voiceContainer = document.createElement('div');
                        voiceContainer.className = 'voice-message-player';
                        voiceContainer.innerHTML = `
                            <button type="button" class="voice-play-btn" data-audio-id="${audioId}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                            </button>
                            <div class="voice-waveform-display">${generateWaveformBars(15)}</div>
                            <span class="voice-duration-display">0:00</span>
                            <audio id="${audioId}" src="${att.url}" style="display:none"></audio>
                        `;
                        bubbleDiv.appendChild(voiceContainer);
                        setTimeout(() => setupVoicePlayer(audioId, voiceContainer), 100);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    } else {
                        const link = document.createElement('a');
                        link.href = att.url;
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.textContent = att.fileName || 'Download file';
                        bubbleDiv.appendChild(link);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    }
                } else {
                    bubbleDiv.textContent = message.content;
                }

                // Create timestamp element
                const timestampDiv = document.createElement('div');
                timestampDiv.classList.add('message-timestamp');
                
                // Format timestamp
                let formattedTime = '';
                if (message.sentAt || message.timestamp) {
                    const msgDate = new Date(message.sentAt || message.timestamp);
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const msgDateOnly = new Date(msgDate.getFullYear(), msgDate.getMonth(), msgDate.getDate());
                    
                    if (msgDateOnly.getTime() === today.getTime()) {
                        // Today - show only time
                        formattedTime = msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit',
                            timeZone: 'Asia/Ho_Chi_Minh'
                        });
                    } else if (msgDateOnly.getTime() === today.getTime() - 24 * 60 * 60 * 1000) {
                        // Yesterday
                        formattedTime = 'HÃ´m qua ' + msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit',
                            timeZone: 'Asia/Ho_Chi_Minh'
                        });
                    } else {
                        // Older - show date and time
                        formattedTime = msgDate.toLocaleDateString('vi-VN', { 
                            day: '2-digit', 
                            month: '2-digit',
                            year: 'numeric',
                            timeZone: 'Asia/Ho_Chi_Minh'
                        }) + ' ' + msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit',
                            timeZone: 'Asia/Ho_Chi_Minh'
                        });
                    }
                } else {
                    // Fallback for messages without timestamp
                    formattedTime = new Date().toLocaleTimeString('vi-VN', { 
                        hour: '2-digit', 
                        minute: '2-digit',
                        timeZone: 'Asia/Ho_Chi_Minh'
                    });
                }
                
                timestampDiv.textContent = formattedTime;
                
                // Add click handler to toggle timestamp
                bubbleDiv.addEventListener('click', function() {
                    timestampDiv.classList.toggle('show');
                });
                
                // Assemble the message
                bubbleContainer.appendChild(bubbleDiv);
                bubbleContainer.appendChild(timestampDiv);
                messageRow.appendChild(bubbleContainer);
                
                return messageRow;
            }

            function renderConversationList() {
                conversationListEl.innerHTML = '';
                conversations
                    .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))
                    .forEach(convo => {
                        const convoEl = document.createElement('div');
                        convoEl.className = 'conversation-item';
                        if (selectedConversation && convo.id === selectedConversation.id) {
                            convoEl.classList.add('selected');
                        }
                        convoEl.dataset.conversationId = convo.id;

                        const unreadBadge = (convo.unreadMessageCount || 0) > 0 ? `<span class=\"badge-unread\">${convo.unreadMessageCount}</span>` : '';

                        const productTopicHtml = convo.productContext
                            ? `<p class="product-topic">Topic: ${convo.productContext.name}</p>`
                            : '';

                        convoEl.innerHTML = `
                        <div class="avatar">
                            <img src="${convo.otherParticipant.profilePictureUrl || 'https://via.placeholder.com/100'}" />
                        </div>
                        <div class="details">
                            <div class="header">
                                <p class="name">${convo.otherParticipant.fullName}
                                    ${convo.otherParticipant.role ? `<span style=\"margin-left:6px; font-size:12px; color:${convo.otherParticipant.role.toLowerCase()==='admin' ? '#dc2626' : '#6b7280'};\">(${convo.otherParticipant.role})</span>` : ''}
                                </p>
                                ${unreadBadge}
                            </div>
                            ${productTopicHtml}
                            <p class="last-message">${convo.lastMessageContent || 'No messages yet'}</p>
                        </div>
                    `;

                        convoEl.addEventListener('click', () => selectConversation(convo.id));
                        conversationListEl.appendChild(convoEl);
                    });
            }

            async function loadConversations() {
                try {
                    // âœ… Cache-busting: Force fresh data má»—i láº§n load
                    const response = await fetch(`${apiUrl}/conversations?_=${Date.now()}`, {
                        headers: { 
                            'Authorization': 'Bearer ' + accessToken,
                            'Cache-Control': 'no-cache' // âœ… Disable browser cache
                        }
                    });
                    if (!response.ok) throw new Error("Failed to load conversations");
                    conversations = await response.json();
                    renderConversationList();
                } catch (error) {
                    conversationListEl.innerHTML = `<p class="loading-text" style="color: red;">${error.message}</p>`;
                }
            }

            async function loadMessages(conversationId, page) {
                try {
                    const response = await fetch(`${apiUrl}/conversations/${conversationId}/messages?pageNumber=${page}&pageSize=${pageSize}`, {
                        headers: { 'Authorization': 'Bearer ' + accessToken }
                    });
                    if (!response.ok) throw new Error("Failed to load messages");

                    const messages = await response.json();

                    // API tráº£ vá»: newest first (má»›i nháº¥t trÆ°á»›c, cÅ© nháº¥t sau)
                    // Hiá»ƒn thá»‹: oldest on top, newest at bottom (cÅ© nháº¥t á»Ÿ trÃªn, má»›i nháº¥t á»Ÿ dÆ°á»›i)
                    
                    // Reverse Ä‘á»ƒ cÃ³ thá»© tá»±: oldest first (cÅ© nháº¥t trÆ°á»›c, má»›i nháº¥t sau)
                    messages.reverse();
                    
                    if (page === 1) {
                        // Page 1: append tá»«ng tin nháº¯n (cÅ© nháº¥t append trÆ°á»›c â†’ á»Ÿ trÃªn)
                        messages.forEach(msg => {
                            const isMe = msg.senderId.toLowerCase() === currentUserId.toLowerCase();
                            const el = createMessageElement(msg, isMe);
                            messagesContainerEl.appendChild(el);
                        });
                    } else {
                        // Page 2+: prepend vÃ o Ä‘áº§u container
                        // Sau khi reverse: [oldest, ..., newest]
                        // Prepend tá»« cuá»‘i vá» Ä‘áº§u Ä‘á»ƒ oldest á»Ÿ trÃªn cÃ¹ng
                        for (let i = messages.length - 1; i >= 0; i--) {
                            const msg = messages[i];
                            const isMe = msg.senderId.toLowerCase() === currentUserId.toLowerCase();
                            const el = createMessageElement(msg, isMe);
                            messagesContainerEl.insertBefore(el, messagesContainerEl.firstChild);
                        }
                    }

                    return messages.length;
                } catch (err) {
                    console.error(err);
                    return 0;
                }
            }

            async function selectConversation(conversationId) {
                selectedConversation = conversations.find(c => c.id === conversationId);
                if (!selectedConversation) return;

                renderConversationList();

                chatPlaceholderEl.classList.add('hidden');
                chatWindowEl.classList.remove('hidden');
                chatUserNameEl.textContent = selectedConversation.otherParticipant.fullName;

                if (selectedConversation.productContext) {
                    productImageEl.src = selectedConversation.productContext.imageUrl || 'https://via.placeholder.com/100';
                    productNameEl.textContent = selectedConversation.productContext.name;
                    productLinkEl.href = `${window.apiSettings.frontendUrl}/products/detail/${selectedConversation.productContext.id}`;
                    productBannerEl.classList.remove('hidden');
                } else {
                    productBannerEl.classList.add('hidden');
                }

                messagesContainerEl.innerHTML = '';
                currentPage = 1;
                await loadMessages(conversationId, currentPage);
                messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;

                messageInput.disabled = false;
                sendBtn.disabled = false;

                // Mark as read on server and reset badge locally
                try {
                    await fetch(`${apiUrl}/conversations/${conversationId}/mark-read`, {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + accessToken }
                    });
                    const idx = conversations.findIndex(c => c.id === conversationId);
                    if (idx >= 0) { conversations[idx].unreadMessageCount = 0; renderConversationList(); }
                } catch {}
            }

            sendMessageForm.addEventListener('submit', (e) => {
                e.preventDefault();
                if (!selectedConversation) return;

                const messageText = messageInput.value.trim();
                if (messageText && signalRConnection) {
                    const recipientId = selectedConversation.otherParticipant.userId;

                    // Create temporary message with timestamp for immediate display
                    const tempMessage = {
                        content: messageText,
                        senderId: currentUserId,
                        sentAt: new Date().toISOString()
                    };
                    
                    // Display message immediately
                    const el = createMessageElement(tempMessage, true);
                    messagesContainerEl.appendChild(el);
                    messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;

                    signalRConnection.invoke("SendMessageAsync", selectedConversation.id, recipientId, messageText, null)
                        .then(() => {
                            messageInput.value = '';
                        })
                        .catch(err => {
                            console.error("Failed to send message:", err);
                            alert("Could not send message. Please try again.");
                        });
                }
            });

            // Attach icon + upload flow reused from provider/customer
            const uploadInput = document.createElement('input');
            uploadInput.type = 'file';
            uploadInput.style.display = 'none';
            uploadInput.accept = 'image/*,video/*,*/*';
            uploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                uploadInput.value = '';
                if (!file || !selectedConversation || !signalRConnection) return;
                
                // Video size limit: 25MB for luxury rental web
                const MAX_VIDEO_SIZE = 25 * 1024 * 1024; // 25MB
                if (file.type.startsWith('video/') && file.size > MAX_VIDEO_SIZE) {
                    alert('Video file is too large. Maximum size is 25MB.');
                    return;
                }
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    const res = await fetch(`${apiUrl}/chat/attachments`, {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + accessToken },
                        body: formData
                    });
                    if (!res.ok) throw new Error('Upload failed');
                    const { data } = await res.json();
                    const recipientId = selectedConversation.otherParticipant.userId;
                    await signalRConnection.invoke('SendMessageWithAttachmentAsync',
                        selectedConversation.id,
                        recipientId,
                        messageInput.value.trim() || null,
                        null,
                        data.url,
                        data.type,
                        data.publicId,
                        data.thumbnailUrl,
                        data.mimeType,
                        data.fileName,
                        data.fileSize
                    );
                    messageInput.value = '';
                } catch (err) {
                    console.error(err);
                    alert('Failed to send attachment');
                }
            });

            const attachBtn = document.createElement('button');
            attachBtn.type = 'button';
            attachBtn.title = 'Attach';
            attachBtn.setAttribute('aria-label', 'Attach');
            attachBtn.style.background = 'transparent';
            attachBtn.style.border = 'none';
            attachBtn.style.padding = '0 6px';
            attachBtn.style.cursor = 'pointer';
            attachBtn.style.color = '#000';
            attachBtn.className = 'attach-btn';
            attachBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 1 1 5.66 5.66l-9.2 9.19a2 2 0 1 1-2.83-2.83l8.49-8.48"/></svg>';
            attachBtn.addEventListener('click', () => uploadInput.click());
            sendMessageForm.insertBefore(attachBtn, sendBtn);
            sendMessageForm.appendChild(uploadInput);

            function openLightbox(url) {
                let overlay = document.getElementById('image-lightbox');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'image-lightbox';
                    overlay.style.position = 'fixed';
                    overlay.style.inset = '0';
                    overlay.style.background = 'rgba(0,0,0,0.85)';
                    overlay.style.display = 'flex';
                    overlay.style.alignItems = 'center';
                    overlay.style.justifyContent = 'center';
                    overlay.style.zIndex = '10000';
                    const img = document.createElement('img');
                    img.style.maxWidth = '90%';
                    img.style.maxHeight = '90%';
                    img.style.borderRadius = '8px';
                    overlay.appendChild(img);
                    overlay.addEventListener('click', () => overlay.remove());
                    document.body.appendChild(overlay);
                }
                const imgEl = overlay.querySelector('img');
                imgEl.src = url;
            }

            // Auto open conversation if ?with=<userId>
            async function openWithUserIfProvided() {
                const params = new URLSearchParams(window.location.search);
                const withUserId = params.get('with');
                if (!withUserId) return;
                try {
                    const res = await fetch(`${apiUrl}/conversations/find-or-create`, {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer ' + accessToken,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ recipientId: withUserId })
                    });
                    if (!res.ok) return;
                    const convo = await res.json();
                    await loadConversations();
                    selectConversation(convo.id);
                } catch (e) { console.error(e); }
            }

            async function init() {
                if (!accessToken) {
                    conversationListEl.innerHTML = '<p class="loading-text">Please login to view messages.</p>';
                    return;
                }

                await loadConversations();

                if (!signalRConnection) {
                    signalRConnection = new signalR.HubConnectionBuilder()
                        .withUrl(`${signalRUrl}/chathub?access_token=${accessToken}`)
                        .withAutomaticReconnect()
                        .build();

                    signalRConnection.on("ReceiveMessage", (message) => {
                        const convoToUpdate = conversations.find(c => c.id === message.conversationId);
                        if (convoToUpdate) {
                            // Cáº­p nháº­t lastMessageContent - hiá»ƒn thá»‹ thÃ´ng tin attachment náº¿u cÃ³
                            if (message.attachment) {
                                const attachmentType = message.attachment.type;
                                if (attachmentType === 'image') {
                                    convoToUpdate.lastMessageContent = message.content || 'ðŸ“· Sent an image';
                                } else if (attachmentType === 'video') {
                                    convoToUpdate.lastMessageContent = message.content || 'ðŸŽ¥ Sent a video';
                                } else {
                                    convoToUpdate.lastMessageContent = message.content || `ðŸ“Ž ${message.attachment.fileName || 'Sent a file'}`;
                                }
                            } else {
                                convoToUpdate.lastMessageContent = message.content;
                            }
                            convoToUpdate.updatedAt = message.sentAt;
                            convoToUpdate.productContext = message.productContext;
                            if (!selectedConversation || message.conversationId !== selectedConversation.id) {
                                convoToUpdate.unreadMessageCount = (convoToUpdate.unreadMessageCount || 0) + 1;
                            }
                            renderConversationList();
                        } else {
                            // âœ… NEW: Conversation má»›i (chÆ°a cÃ³ trong danh sÃ¡ch) â†’ Reload
                            console.log("[CHAT] New conversation detected - reloading conversation list");
                            loadConversations(); // Reload Ä‘á»ƒ hiá»ƒn thá»‹ conversation má»›i
                        }

                        if (selectedConversation && message.conversationId === selectedConversation.id) {
                            const isMe = message.senderId.toLowerCase() === currentUserId.toLowerCase();
                            // Hiá»ƒn thá»‹ tin nháº¯n: vá»›i attachment thÃ¬ luÃ´n hiá»ƒn thá»‹, vá»›i text thÃ¬ chá»‰ hiá»ƒn thá»‹ tá»« ngÆ°á»i khÃ¡c
                            const hasAttachment = message.attachment && message.attachment.url;
                            if (!isMe || hasAttachment) {
                                // Náº¿u lÃ  tin nháº¯n cá»§a mÃ¬nh cÃ³ attachment, cáº§n hiá»ƒn thá»‹ vÃ¬ khÃ´ng cÃ³ temp message cho attachment
                                if (isMe && hasAttachment) {
                                    const el = createMessageElement(message, isMe);
                                    messagesContainerEl.appendChild(el);
                                    messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;
                                } else if (!isMe) {
                                    const el = createMessageElement(message, isMe);
                                    messagesContainerEl.appendChild(el);
                                    messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;
                                }
                            }
                            if (message.productContext) {
                                productImageEl.src = message.productContext.imageUrl || 'https://www.shutterstock.com/image-vector/image-icon-trendy-flat-style-600nw-643080895.jpg';
                                productNameEl.textContent = message.productContext.name;
                                productLinkEl.href = `${window.apiSettings.frontendUrl}/products/detail/${message.productContext.id}`;
                                productBannerEl.classList.remove('hidden');
                            }
                        }
                    });

                    try {
                        await signalRConnection.start();
                    } catch (err) {
                        console.error("SignalR Connection Error: ", err);
                    }
                }

                await openWithUserIfProvided();
            }

            init();

            // Initialize Chat Media Features (Emoji, GIF, Voice)
            setTimeout(() => {
                if (typeof ChatMediaFeatures !== 'undefined') {
                    new ChatMediaFeatures({
                        messageInput: messageInput,
                        sendBtn: sendBtn,
                        messageForm: sendMessageForm,
                        apiUrl: apiUrl,
                        accessToken: accessToken,
                        getSelectedConversation: () => selectedConversation,
                        getSignalRConnection: () => signalRConnection
                    });
                }
            }, 100);
        });
    </script>
    <script src="~/js/chat-media-features.js"></script>
}


