@page "/admin/messages"
@model ShareItFE.Pages.Admin.MessagesModel
@{
    ViewData["Title"] = "Admin Messages";
}

<link rel="stylesheet" href="~/css/chat.css" />

<div class="chat-container">
    <div class="conversation-list">
        <div class="conversation-list-header">
            <h2>Messages</h2>
        </div>
        <div id="conversation-list-body" class="conversation-list-body">
            <p class="loading-text">Loading conversations...</p>
        </div>
    </div>

    <div class="chat-view">
        <div id="chat-placeholder" class="chat-placeholder">
            <p>Select a conversation to begin</p>
        </div>

        <div id="chat-window" class="chat-window hidden">
            <div id="chat-header" class="chat-header">
                <h3 id="chat-user-name" class="name"></h3>
            </div>

            <div id="product-context-banner" class="product-context-banner hidden">
                <a id="product-link" href="#" target="_blank" rel="noopener noreferrer">
                    <img id="product-image" src="" alt="Product" />
                    <div>
                        <p class="topic-text">Topic:</p>
                        <p id="product-name" class="product-name"></p>
                    </div>
                </a>
            </div>

            <div id="messages-container" class="messages-container"></div>

            <form id="send-message-form" class="message-form">
                <input type="text" id="message-input" placeholder="Type a message..." autocomplete="off" disabled>
                <button type="submit" id="send-btn" disabled>Send</button>
            </form>
        </div>
    </div>
    
</div>

@section Scripts {
    <script src="~/js/dist/browser/signalr.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const conversationListEl = document.getElementById('conversation-list-body');
            const chatPlaceholderEl = document.getElementById('chat-placeholder');
            const chatWindowEl = document.getElementById('chat-window');
            const chatUserNameEl = document.getElementById('chat-user-name');
            const messagesContainerEl = document.getElementById('messages-container');
            const sendMessageForm = document.getElementById('send-message-form');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const productBannerEl = document.getElementById('product-context-banner');
            const productImageEl = document.getElementById('product-image');
            const productNameEl = document.getElementById('product-name');
            const productLinkEl = document.getElementById('product-link');

            const currentUserId = '@Model.CurrentUserId';
            const accessToken = '@Model.AccessToken';
            const apiUrl = '@Model.ApiBaseUrl';
            const signalRUrl = '@Model.SignalRRootUrl';

            let conversations = [];
            let currentPage = 1;
            const pageSize = 15;
            let selectedConversation = null;
            let signalRConnection = null;
            let isLoadingMore = false;

            function createMessageElement(message, isMe) {
                const messageRow = document.createElement('div');
                messageRow.className = isMe ? 'message-row me' : 'message-row them';

                // Create container for bubble and timestamp
                const bubbleContainer = document.createElement('div');
                bubbleContainer.classList.add('message-bubble-container', isMe ? 'me' : 'them');

                const bubbleDiv = document.createElement('div');
                bubbleDiv.className = 'message-bubble';
                if (isMe) {
                    bubbleDiv.classList.add('me');
                } else {
                    bubbleDiv.classList.add('them');
                }
                
                if (message.attachment) {
                    const att = message.attachment;
                    if (att.type === 'image') {
                        const img = document.createElement('img');
                        img.src = att.url;
                        img.alt = att.fileName || 'image';
                        img.style.maxWidth = '260px';
                        img.style.borderRadius = '8px';
                        img.style.cursor = 'zoom-in';
                        img.addEventListener('click', () => openLightbox(att.url));
                        bubbleDiv.appendChild(img);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    } else if (att.type === 'video') {
                        const video = document.createElement('video');
                        video.src = att.url;
                        video.controls = true;
                        video.style.maxWidth = '260px';
                        video.style.borderRadius = '8px';
                        bubbleDiv.appendChild(video);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    } else {
                        const link = document.createElement('a');
                        link.href = att.url;
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.textContent = att.fileName || 'Download file';
                        bubbleDiv.appendChild(link);
                        if (message.content) {
                            const caption = document.createElement('div');
                            caption.textContent = message.content;
                            caption.style.marginTop = '6px';
                            bubbleDiv.appendChild(caption);
                        }
                    }
                } else {
                    bubbleDiv.textContent = message.content;
                }

                // Create timestamp element
                const timestampDiv = document.createElement('div');
                timestampDiv.classList.add('message-timestamp');
                
                // Format timestamp
                let formattedTime = '';
                if (message.sentAt || message.timestamp) {
                    const msgDate = new Date(message.sentAt || message.timestamp);
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const msgDateOnly = new Date(msgDate.getFullYear(), msgDate.getMonth(), msgDate.getDate());
                    
                    if (msgDateOnly.getTime() === today.getTime()) {
                        // Today - show only time
                        formattedTime = msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    } else if (msgDateOnly.getTime() === today.getTime() - 24 * 60 * 60 * 1000) {
                        // Yesterday
                        formattedTime = 'HÃ´m qua ' + msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    } else {
                        // Older - show date and time
                        formattedTime = msgDate.toLocaleDateString('vi-VN', { 
                            day: '2-digit', 
                            month: '2-digit',
                            year: 'numeric'
                        }) + ' ' + msgDate.toLocaleTimeString('vi-VN', { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    }
                } else {
                    // Fallback for messages without timestamp
                    formattedTime = new Date().toLocaleTimeString('vi-VN', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                }
                
                timestampDiv.textContent = formattedTime;
                
                // Add click handler to toggle timestamp
                bubbleDiv.addEventListener('click', function() {
                    timestampDiv.classList.toggle('show');
                });
                
                // Assemble the message
                bubbleContainer.appendChild(bubbleDiv);
                bubbleContainer.appendChild(timestampDiv);
                messageRow.appendChild(bubbleContainer);
                
                return messageRow;
            }

            function renderConversationList() {
                conversationListEl.innerHTML = '';
                conversations
                    .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))
                    .forEach(convo => {
                        const convoEl = document.createElement('div');
                        convoEl.className = 'conversation-item';
                        if (selectedConversation && convo.id === selectedConversation.id) {
                            convoEl.classList.add('selected');
                        }
                        convoEl.dataset.conversationId = convo.id;

                        const unreadBadge = (convo.unreadMessageCount || 0) > 0 ? `<span class=\"badge-unread\">${convo.unreadMessageCount}</span>` : '';

                        const productTopicHtml = convo.productContext
                            ? `<p class="product-topic">Topic: ${convo.productContext.name}</p>`
                            : '';

                        convoEl.innerHTML = `
                        <div class="avatar">
                            <img src="${convo.otherParticipant.profilePictureUrl || 'https://via.placeholder.com/100'}" />
                        </div>
                        <div class="details">
                            <div class="header">
                                <p class="name">${convo.otherParticipant.fullName}
                                    ${convo.otherParticipant.role ? `<span style=\"margin-left:6px; font-size:12px; color:${convo.otherParticipant.role.toLowerCase()==='admin' ? '#dc2626' : '#6b7280'};\">(${convo.otherParticipant.role})</span>` : ''}
                                </p>
                                ${unreadBadge}
                            </div>
                            ${productTopicHtml}
                            <p class="last-message">${convo.lastMessageContent || 'No messages yet'}</p>
                        </div>
                    `;

                        convoEl.addEventListener('click', () => selectConversation(convo.id));
                        conversationListEl.appendChild(convoEl);
                    });
            }

            async function loadConversations() {
                try {
                    const response = await fetch(`${apiUrl}/conversations`, {
                        headers: { 'Authorization': 'Bearer ' + accessToken }
                    });
                    if (!response.ok) throw new Error("Failed to load conversations");
                    conversations = await response.json();
                    renderConversationList();
                } catch (error) {
                    conversationListEl.innerHTML = `<p class="loading-text" style="color: red;">${error.message}</p>`;
                }
            }

            async function loadMessages(conversationId, page) {
                try {
                    const response = await fetch(`${apiUrl}/conversations/${conversationId}/messages?pageNumber=${page}&pageSize=${pageSize}`, {
                        headers: { 'Authorization': 'Bearer ' + accessToken }
                    });
                    if (!response.ok) throw new Error("Failed to load messages");

                    const messages = await response.json();

                    messages.reverse().forEach(msg => {
                        const isMe = msg.senderId.toLowerCase() === currentUserId.toLowerCase();
                        const el = createMessageElement(msg, isMe);
                        messagesContainerEl.insertBefore(el, messagesContainerEl.firstChild);
                    });

                    return messages.length;
                } catch (err) {
                    console.error(err);
                    return 0;
                }
            }

            async function selectConversation(conversationId) {
                selectedConversation = conversations.find(c => c.id === conversationId);
                if (!selectedConversation) return;

                renderConversationList();

                chatPlaceholderEl.classList.add('hidden');
                chatWindowEl.classList.remove('hidden');
                chatUserNameEl.textContent = selectedConversation.otherParticipant.fullName;

                if (selectedConversation.productContext) {
                    productImageEl.src = selectedConversation.productContext.imageUrl || 'https://via.placeholder.com/100';
                    productNameEl.textContent = selectedConversation.productContext.name;
                    productLinkEl.href = `${window.apiSettings.frontendUrl}/products/detail/${selectedConversation.productContext.id}`;
                    productBannerEl.classList.remove('hidden');
                } else {
                    productBannerEl.classList.add('hidden');
                }

                messagesContainerEl.innerHTML = '';
                currentPage = 1;
                await loadMessages(conversationId, currentPage);
                messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;

                messageInput.disabled = false;
                sendBtn.disabled = false;

                // Mark as read on server and reset badge locally
                try {
                    await fetch(`${apiUrl}/conversations/${conversationId}/mark-read`, {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + accessToken }
                    });
                    const idx = conversations.findIndex(c => c.id === conversationId);
                    if (idx >= 0) { conversations[idx].unreadMessageCount = 0; renderConversationList(); }
                } catch {}
            }

            sendMessageForm.addEventListener('submit', (e) => {
                e.preventDefault();
                if (!selectedConversation) return;

                const messageText = messageInput.value.trim();
                if (messageText && signalRConnection) {
                    const recipientId = selectedConversation.otherParticipant.userId;

                    // Create temporary message with timestamp for immediate display
                    const tempMessage = {
                        content: messageText,
                        senderId: currentUserId,
                        sentAt: new Date().toISOString()
                    };
                    
                    // Display message immediately
                    const el = createMessageElement(tempMessage, true);
                    messagesContainerEl.appendChild(el);
                    messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;

                    signalRConnection.invoke("SendMessageAsync", selectedConversation.id, recipientId, messageText, null)
                        .then(() => {
                            messageInput.value = '';
                        })
                        .catch(err => {
                            console.error("Failed to send message:", err);
                            alert("Could not send message. Please try again.");
                        });
                }
            });

            // Attach icon + upload flow reused from provider/customer
            const uploadInput = document.createElement('input');
            uploadInput.type = 'file';
            uploadInput.style.display = 'none';
            uploadInput.accept = 'image/*,video/*,*/*';
            uploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                uploadInput.value = '';
                if (!file || !selectedConversation || !signalRConnection) return;
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    const res = await fetch(`${apiUrl}/chat/attachments`, {
                        method: 'POST',
                        headers: { 'Authorization': 'Bearer ' + accessToken },
                        body: formData
                    });
                    if (!res.ok) throw new Error('Upload failed');
                    const { data } = await res.json();
                    const recipientId = selectedConversation.otherParticipant.userId;
                    await signalRConnection.invoke('SendMessageWithAttachmentAsync',
                        selectedConversation.id,
                        recipientId,
                        messageInput.value.trim() || null,
                        null,
                        data.url,
                        data.type,
                        data.publicId,
                        data.thumbnailUrl,
                        data.mimeType,
                        data.fileName,
                        data.fileSize
                    );
                    messageInput.value = '';
                } catch (err) {
                    console.error(err);
                    alert('Failed to send attachment');
                }
            });

            const attachBtn = document.createElement('button');
            attachBtn.type = 'button';
            attachBtn.title = 'Attach';
            attachBtn.setAttribute('aria-label', 'Attach');
            attachBtn.style.background = 'transparent';
            attachBtn.style.border = 'none';
            attachBtn.style.padding = '0 6px';
            attachBtn.style.cursor = 'pointer';
            attachBtn.style.color = '#000';
            attachBtn.className = 'attach-btn';
            attachBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 1 1 5.66 5.66l-9.2 9.19a2 2 0 1 1-2.83-2.83l8.49-8.48"/></svg>';
            attachBtn.addEventListener('click', () => uploadInput.click());
            sendMessageForm.insertBefore(attachBtn, sendBtn);
            sendMessageForm.appendChild(uploadInput);

            function openLightbox(url) {
                let overlay = document.getElementById('image-lightbox');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'image-lightbox';
                    overlay.style.position = 'fixed';
                    overlay.style.inset = '0';
                    overlay.style.background = 'rgba(0,0,0,0.85)';
                    overlay.style.display = 'flex';
                    overlay.style.alignItems = 'center';
                    overlay.style.justifyContent = 'center';
                    overlay.style.zIndex = '10000';
                    const img = document.createElement('img');
                    img.style.maxWidth = '90%';
                    img.style.maxHeight = '90%';
                    img.style.borderRadius = '8px';
                    overlay.appendChild(img);
                    overlay.addEventListener('click', () => overlay.remove());
                    document.body.appendChild(overlay);
                }
                const imgEl = overlay.querySelector('img');
                imgEl.src = url;
            }

            // Auto open conversation if ?with=<userId>
            async function openWithUserIfProvided() {
                const params = new URLSearchParams(window.location.search);
                const withUserId = params.get('with');
                if (!withUserId) return;
                try {
                    const res = await fetch(`${apiUrl}/conversations/find-or-create`, {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer ' + accessToken,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ recipientId: withUserId })
                    });
                    if (!res.ok) return;
                    const convo = await res.json();
                    await loadConversations();
                    selectConversation(convo.id);
                } catch (e) { console.error(e); }
            }

            async function init() {
                if (!accessToken) {
                    conversationListEl.innerHTML = '<p class="loading-text">Please login to view messages.</p>';
                    return;
                }

                await loadConversations();

                if (!signalRConnection) {
                    signalRConnection = new signalR.HubConnectionBuilder()
                        .withUrl(`${signalRUrl}/chathub?access_token=${accessToken}`)
                        .withAutomaticReconnect()
                        .build();

                    signalRConnection.on("ReceiveMessage", (message) => {
                        const convoToUpdate = conversations.find(c => c.id === message.conversationId);
                        if (convoToUpdate) {
                            convoToUpdate.lastMessageContent = message.content;
                            convoToUpdate.updatedAt = message.sentAt;
                            convoToUpdate.productContext = message.productContext;
                            if (!selectedConversation || message.conversationId !== selectedConversation.id) {
                                convoToUpdate.unreadMessageCount = (convoToUpdate.unreadMessageCount || 0) + 1;
                            }
                            renderConversationList();
                        }

                        if (selectedConversation && message.conversationId === selectedConversation.id) {
                            const isMe = message.senderId.toLowerCase() === currentUserId.toLowerCase();
                            const el = createMessageElement(message, isMe);
                            messagesContainerEl.appendChild(el);
                            messagesContainerEl.scrollTop = messagesContainerEl.scrollHeight;
                            if (message.productContext) {
                                productImageEl.src = message.productContext.imageUrl || 'https://www.shutterstock.com/image-vector/image-icon-trendy-flat-style-600nw-643080895.jpg';
                                productNameEl.textContent = message.productContext.name;
                                productLinkEl.href = `${window.apiSettings.frontendUrl}/products/detail/${message.productContext.id}`;
                                productBannerEl.classList.remove('hidden');
                            }
                        }
                    });

                    try {
                        await signalRConnection.start();
                    } catch (err) {
                        console.error("SignalR Connection Error: ", err);
                    }
                }

                await openWithUserIfProvided();
            }

            init();
        });
    </script>
}


